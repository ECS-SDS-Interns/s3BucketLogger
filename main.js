const { app, BrowserWindow, ipcMain, dialog } = require("electron");
const path = require("path");
const fs = require("fs");
const AWS = require("aws-sdk");
const os = require("os");

// Keep a global reference of the window object
let mainWindow;

function createWindow() {
  // Create the browser window
  mainWindow = new BrowserWindow({
    width: 900,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, "preload.js"),
      webSecurity: true,
    },
    icon: path.join(__dirname, "assets", "logo.png"),
  });

  // Load the index.html file
  mainWindow.loadFile("index.html");
}

// Create window when Electron is ready
app.whenReady().then(createWindow);

// Quit when all windows are closed
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") app.quit();
});

app.on("activate", () => {
  if (mainWindow === null) createWindow();
});

// Handle directory selection
ipcMain.handle("select-directory", async () => {
  const result = await dialog.showOpenDialog(mainWindow, {
    properties: ["openDirectory"],
  });
  
  if (result.canceled) {
    return null;
  } else {
    return result.filePaths[0];
  }
});

// Get default directory
ipcMain.handle("get-default-directory", async () => {
  if (process.platform === "win32") {
    return path.join(os.homedir(), "Downloads");
  } else if (process.platform === "darwin") {
    return path.join(os.homedir(), "Downloads");
  } else {
    return os.homedir();
  }
});

// Handle S3 listing request from renderer
ipcMain.handle("list-s3-bucket", async (event, credentials) => {
  try {
    const s3 = new AWS.S3({
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      region: credentials.region,
      maxRetries: 3,
    });

    const bucketName = credentials.bucketName;
    const logFilePath = credentials.logFilePath;

    let logContent = `S3 BUCKET LOG - ${bucketName}\n`;
    logContent += `Generated on: ${new Date().toISOString()}\n`;
    logContent += `Generated by: ${os.userInfo().username}\n`;
    logContent += `${"=".repeat(50)}\n\n`;

    let allItems = [];
    let totalProcessed = 0;
    let continuationToken;

    // Notify progress start
    mainWindow.webContents.send("progress-update", {
      status: "started",
      message: "Starting to list S3 objects...",
    });

    // Use a higher maxKeys value to retrieve more objects per request (max is 1000)
    const maxKeys = 1000;
    
    do {
      const params = { Bucket: bucketName, MaxKeys: maxKeys };
      
      if (continuationToken) {
        params.ContinuationToken = continuationToken;
      }

      // Using listObjectsV2 which is faster than listObjects
      const response = await s3.listObjectsV2(params).promise();

      if (response.Contents && response.Contents.length > 0) {
        // Add to our collection
        allItems = [...allItems, ...response.Contents];
        totalProcessed += response.Contents.length;

        // Send progress update every 5000 objects to reduce UI updates
        if (totalProcessed % 5000 === 0 || !response.IsTruncated) {
          mainWindow.webContents.send("progress-update", {
            status: "processing",
            processed: totalProcessed,
            message: `Retrieved ${totalProcessed} objects from S3 bucket...`,
          });
        }
      }

      continuationToken = response.NextContinuationToken;
    } while (continuationToken);

    // Process in batches for better memory management
    const batchSize = 10000;
    const itemsByFolder = {};
    
    for (let i = 0; i < allItems.length; i += batchSize) {
      const batch = allItems.slice(i, i + batchSize);
      
      batch.forEach((item) => {
        const key = item.Key;
        const parts = key.split("/");

        // If there's a folder structure (contains /)
        if (parts.length > 1) {
          const folderPath = parts.slice(0, -1).join("/");
          const fileName = parts[parts.length - 1];

          if (!itemsByFolder[folderPath]) {
            itemsByFolder[folderPath] = [];
          }

          itemsByFolder[folderPath].push({
            name: fileName,
            lastModified: item.LastModified,
            size: item.Size,
            storageClass: item.StorageClass,
            etag: item.ETag,
          });
        } else {
          // Root-level files
          if (!itemsByFolder[""]) {
            itemsByFolder[""] = [];
          }

          itemsByFolder[""].push({
            name: key,
            lastModified: item.LastModified,
            size: item.Size,
            storageClass: item.StorageClass,
            etag: item.ETag,
          });
        }
      });
      
      // Update progress on batch processing
      mainWindow.webContents.send("progress-update", {
        status: "organizing",
        processed: Math.min(i + batchSize, allItems.length),
        total: allItems.length,
        message: `Organizing ${Math.min(i + batchSize, allItems.length)} of ${allItems.length} objects...`,
      });
    }

    // Format the log content with folders and their contents
    logContent += `Total Objects: ${totalProcessed}\n\n`;

    Object.keys(itemsByFolder).forEach((folder) => {
      const files = itemsByFolder[folder];
      const currentDate = new Date().toISOString().split("T")[0];
      const currentTime = new Date().toTimeString().split(" ")[0];

      if (folder) {
        logContent += `[${currentDate} ${currentTime}] Folder: ${folder}\n`;
      } else {
        logContent += `[${currentDate} ${currentTime}] Root Files:\n`;
      }

      files.forEach((file) => {
        logContent += `- ${file.name}\n`;
      });

      logContent += "\n";
    });

    // Create directory if it doesn't exist
    const logFileDir = path.dirname(logFilePath);
    if (!fs.existsSync(logFileDir)) {
      fs.mkdirSync(logFileDir, { recursive: true });
    }

    // Write to log file
    fs.writeFileSync(logFilePath, logContent);

    // Notify completion
    mainWindow.webContents.send("progress-update", {
      status: "completed",
      message: `Successfully logged ${totalProcessed} items to log file`,
      totalItems: totalProcessed,
    });

    return {
      success: true,
      message: `Successfully logged ${totalProcessed} items from bucket ${bucketName} to ${logFilePath}`,
      itemCount: totalProcessed,
    };
  } catch (error) {
    mainWindow.webContents.send("progress-update", {
      status: "error",
      message: error.message,
    });

    return {
      success: false,
      message: error.message,
    };
  }
});

// Handle local folder scan request from renderer
ipcMain.handle("scan-local-folder", async (event, options) => {
  try {
    const folderPath = options.folderPath;
    const logFilePath = options.logFilePath;

    let logContent = `LOCAL FOLDER LOG - ${folderPath}\n`;
    logContent += `Generated on: ${new Date().toISOString()}\n`;
    logContent += `Generated by: ${os.userInfo().username}\n`;
    logContent += `${"=".repeat(50)}\n\n`;

    // Notify progress start
    mainWindow.webContents.send("progress-update", {
      status: "started",
      message: "Starting to scan local folder...",
    });

    // Check if directory exists
    if (!fs.existsSync(folderPath) || !fs.statSync(folderPath).isDirectory()) {
      throw new Error(`The folder path does not exist or is not a directory: ${folderPath}`);
    }

    // Scan directory recursively
    const files = [];
    let processedCount = 0;
    
    async function scanDirectory(dir, relativePath = '') {
      const entries = fs.readdirSync(dir);
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry);
        const stats = fs.statSync(fullPath);
        const entryRelativePath = path.join(relativePath, entry).replace(/\\/g, '/');
        
        if (stats.isDirectory()) {
          await scanDirectory(fullPath, entryRelativePath);
        } else {
          files.push({
            path: entryRelativePath,
            size: stats.size,
            lastModified: stats.mtime,
          });
          
          processedCount++;
          if (processedCount % 1000 === 0) {
            mainWindow.webContents.send("progress-update", {
              status: "processing",
              processed: processedCount,
              message: `Processed ${processedCount} files...`,
            });
          }
        }
      }
    }
    
    await scanDirectory(folderPath);

    // Group files by directory
    const filesByFolder = {};
    for (const file of files) {
      const dirName = path.dirname(file.path);
      
      if (!filesByFolder[dirName]) {
        filesByFolder[dirName] = [];
      }
      
      filesByFolder[dirName].push({
        name: path.basename(file.path),
        size: file.size,
        lastModified: file.lastModified
      });
    }

    // Format the log content with folders and their contents
    logContent += `Total Files: ${files.length}\n\n`;

    Object.keys(filesByFolder).forEach((folder, index) => {
      const currentFiles = filesByFolder[folder];
      const currentDate = new Date().toISOString().split("T")[0];
      const currentTime = new Date().toTimeString().split(" ")[0];
      
      if (folder === '.') {
        logContent += `[${currentDate} ${currentTime}] Root Files:\n`;
      } else {
        logContent += `[${currentDate} ${currentTime}] Folder: ${folder}\n`;
      }
      
      currentFiles.forEach((file) => {
        logContent += `- ${file.name}\n`;
      });
      
      logContent += '\n';
      
      // Update progress
      mainWindow.webContents.send("progress-update", {
        status: "organizing",
        processed: index + 1,
        total: Object.keys(filesByFolder).length,
        message: `Processing folders (${index + 1}/${Object.keys(filesByFolder).length})...`,
      });
    });

    // Create directory if it doesn't exist
    const logFileDir = path.dirname(logFilePath);
    if (!fs.existsSync(logFileDir)) {
      fs.mkdirSync(logFileDir, { recursive: true });
    }

    // Write to log file
    fs.writeFileSync(logFilePath, logContent);
    
    // Notify completion
    mainWindow.webContents.send("progress-update", {
      status: "completed",
      message: `Successfully logged ${files.length} files to log file`,
      totalItems: files.length,
    });

    return {
      success: true,
      message: `Successfully logged ${files.length} files from ${folderPath} to ${logFilePath}`,
      itemCount: files.length,
    };
  } catch (error) {
    mainWindow.webContents.send("progress-update", {
      status: "error",
      message: error.message,
    });

    return {
      success: false,
      message: error.message,
    };
  }
});